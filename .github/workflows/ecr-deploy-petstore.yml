name: Build, Push to ECR, Deploy to EC2
# updated with validation + safer IMAGE_URI handling

on:
  push:
    branches: ["main"]     # manual only; change to ["main"] when ready
  workflow_dispatch:

env:
  # Pull values from repo/org Variables (Settings → Secrets and variables → Actions → Variables)
  AWS_ACCOUNT_ID: ${{ vars.AWS_ACCOUNT_ID }}
  AWS_REGION: ${{ vars.AWS_REGION }}
  ECR_REPO: ${{ vars.ECR_REPO }}
  IMAGE_TAG: latest
  DEPLOY_TAG_KEY: ${{ vars.DEPLOY_TAG_KEY }}
  DEPLOY_TAG_VALUE: ${{ vars.DEPLOY_TAG_VALUE }}

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read

    steps:
      - name: Validate required vars are present
        run: |
          set -e
          MISSING=()
          for v in AWS_ACCOUNT_ID AWS_REGION ECR_REPO IMAGE_TAG; do
            if [ -z "${!v:-}" ]; then MISSING+=("$v"); fi
          done
          # DEPLOY_TAG_* not needed for this job, so don't fail here on them
          if [ ${#MISSING[@]} -gt 0 ]; then
            echo "Missing required variables: ${MISSING[*]}"
            echo "Set them under: GitHub → Repo → Settings → Secrets and variables → Actions → Variables"
            exit 1
          fi

      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ vars.AWS_ROLE_TO_ASSUME }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Compute IMAGE_URI for this run
        run: |
          echo "IMAGE_URI=${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/${ECR_REPO}:${IMAGE_TAG}" >> "$GITHUB_ENV"

      - name: Ensure ECR repository exists
        run: |
          aws ecr describe-repositories --repository-names "$ECR_REPO" >/dev/null 2>&1 || \
          aws ecr create-repository --repository-name "$ECR_REPO" >/dev/null

      - name: Login to Amazon ECR
        uses: aws-actions/amazon-ecr-login@v2

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build and push
        uses: docker/build-push-action@v6
        with:
          context: .
          push: true
          tags: ${{ env.IMAGE_URI }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

  deploy-to-ec2:
    runs-on: ubuntu-latest
    needs: build-and-push
    permissions:
      id-token: write
      contents: read

    steps:
      - name: Validate deploy vars are present
        run: |
          set -e
          MISSING=()
          for v in AWS_ACCOUNT_ID AWS_REGION ECR_REPO IMAGE_TAG DEPLOY_TAG_KEY DEPLOY_TAG_VALUE; do
            if [ -z "${!v:-}" ]; then MISSING+=("$v"); fi
          done
          if [ ${#MISSING[@]} -gt 0 ]; then
            echo "Missing required variables for deploy: ${MISSING[*]}"
            echo "Set them under: GitHub → Repo → Settings → Secrets and variables → Actions → Variables"
            exit 1
          fi
          echo "IMAGE_URI=${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/${ECR_REPO}:${IMAGE_TAG}" >> "$GITHUB_ENV"

      - name: Configure AWS credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ vars.AWS_ROLE_TO_ASSUME }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Find instances by tag
        id: find
        run: |
          set -euo pipefail
          echo "Looking for instances with tag ${DEPLOY_TAG_KEY}=${DEPLOY_TAG_VALUE} in ${AWS_REGION}"
          INSTANCE_IDS=$(aws ec2 describe-instances \
            --filters "Name=tag:${DEPLOY_TAG_KEY},Values=${DEPLOY_TAG_VALUE}" "Name=instance-state-name,Values=running" \
            --query "Reservations[].Instances[].InstanceId" --output text)
          if [ -z "${INSTANCE_IDS}" ]; then
            echo "No running instances found with ${DEPLOY_TAG_KEY}=${DEPLOY_TAG_VALUE}"
            exit 1
          fi
          echo "Targeting instances: ${INSTANCE_IDS}"
          echo "instance_ids=${INSTANCE_IDS}" >> "$GITHUB_OUTPUT"

      - name: Sanity — caller and region
        run: |
          set -euo pipefail
          echo "AWS_REGION=${AWS_REGION}"
          aws sts get-caller-identity

      - name: Guard — instance must be Online in SSM
        env:
          INSTANCE_ID: ${{ steps.find.outputs.instance_ids }}
        run: |
          set -euo pipefail
          echo "Checking SSM status for ${INSTANCE_ID} in ${AWS_REGION}"
          aws ssm describe-instance-information --region "${AWS_REGION}" \
            --query "InstanceInformationList[?InstanceId==\`${INSTANCE_ID}\`].[InstanceId,PingStatus,AgentVersion,LastPingDateTime]" \
            --output table || true

          PING=$(aws ssm describe-instance-information --region "${AWS_REGION}" \
            --query "InstanceInformationList[?InstanceId==\`${INSTANCE_ID}\`].PingStatus | [0]" \
            --output text || echo "None")

          if [ "${PING}" != "Online" ]; then
            echo "::error::Instance ${INSTANCE_ID} is not Online in SSM (PingStatus=${PING})."
            echo "Fix: ensure IAM instance profile attached (AmazonSSMManagedInstanceCore + ECRReadOnly), agent running, and egress to ssm/ec2messages/ssmmessages in ${AWS_REGION}."
            exit 1
          fi

      - name: Deploy via SSM (debug, sudo-docker fallback, extra logs)
        id: ssm
        env:
          REPO_URI: ${{ env.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/${{ env.ECR_REPO }}
          IMAGE_TAG: ${{ env.IMAGE_TAG }}
          AWS_REGION: ${{ env.AWS_REGION }}
          AWS_ACCOUNT_ID: ${{ env.AWS_ACCOUNT_ID }}
          INSTANCE_IDS: ${{ steps.find.outputs.instance_ids }}
          DEBUG: "1"
        run: |
          set -euo pipefail
          [ "${DEBUG}" = "1" ] && set -x || true
      
          REPO="${REPO_URI}:${IMAGE_TAG}"
      
          # Render the remote script robustly (no read -d '' pitfalls)
          REMOTE_SCRIPT="$(cat <<'EOS'
          #!/bin/bash
          set -euo pipefail
          [ "${DEBUG:-}" = "1" ] && set -x || true
          
          AWS_REGION="${AWS_REGION:-__MISSING__}"
          AWS_ACCOUNT_ID="${AWS_ACCOUNT_ID:-__MISSING__}"
          REPO="${REPO:-__MISSING__}"
          
          echo "=== ENV ==="
          echo "AWS_REGION=${AWS_REGION}"
          echo "AWS_ACCOUNT_ID=${AWS_ACCOUNT_ID}"
          echo "REPO=${REPO}"
          echo "USER=$(whoami)"
          
          echo "=== Ensure Docker installed & running ==="
          if ! command -v docker >/dev/null 2>&1; then
            if command -v apt-get >/dev/null 2>&1; then
              sudo apt-get update -y
              # install docker + awscli if missing
              sudo apt-get install -y docker.io awscli || true
              sudo systemctl enable --now docker || true
            elif command -v dnf >/dev/null 2>&1; then
              sudo dnf install -y docker awscli || true
              sudo systemctl enable --now docker || true
            elif command -v yum >/dev/null 2>&1; then
              sudo yum install -y docker awscli || true
              sudo systemctl enable --now docker || true
            else
              echo "No supported package manager found to install Docker/awscli." >&2
              exit 2
            fi
          fi
          
          # Make sure service is up (ignore failures on distros without systemd)
          sudo systemctl start docker 2>/dev/null || true
          sleep 2
          
          # Decide whether we must sudo docker (permission denied case)
          DOCKER_BIN="docker"
          if ! docker info >/dev/null 2>&1; then
            if sudo docker info >/dev/null 2>&1; then
              DOCKER_BIN="sudo docker"
              echo "Using sudo for docker commands."
            else
              echo "Docker daemon not reachable. Service status:"
              sudo systemctl status docker --no-pager || true
              echo "Recent docker logs:"
              journalctl -u docker --no-pager -n 200 || true
              exit 3
            fi
          fi
          
          echo "docker version:"
          ${DOCKER_BIN} version || true
          echo "docker info (truncated):"
          ${DOCKER_BIN} info 2>/dev/null | head -n 50 || true
          
          echo "=== Ensure awscli available ==="
          if ! command -v aws >/dev/null 2>&1; then
            echo "awscli still missing; attempting install fallback…" >&2
            if command -v apt-get >/dev/null 2>&1; then
              sudo apt-get update -y && sudo apt-get install -y awscli || true
            elif command -v dnf >/dev/null 2>&1; then
              sudo dnf install -y awscli || true
            elif command -v yum >/dev/null 2>&1; then
              sudo yum install -y awscli || true
            fi
          fi
          aws --version || { echo "awscli not present on instance"; exit 4; }
          
          echo "=== ECR Login ==="
          # pipe password to the same docker binary we decided to use
          aws ecr get-login-password --region "${AWS_REGION}" \
            | ${DOCKER_BIN} login --username AWS --password-stdin "${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com"
          
          echo "=== Pull & (Re)Run Container ==="
          ${DOCKER_BIN} pull "${REPO}"
          ${DOCKER_BIN} image inspect "${REPO}" >/dev/null
          
          ${DOCKER_BIN} ps -a || true
          ${DOCKER_BIN} stop petstore || true
          ${DOCKER_BIN} rm   petstore || true
          
          # If port 80 is in use, show who has it
          if ss -lntp 2>/dev/null | grep -qE 'LISTEN .*:80 '; then
            echo "Port 80 is in use. Showing holders:"
            ss -lntp | grep -E 'LISTEN .*:80 ' || true
          fi
          
          ${DOCKER_BIN} run -d --name petstore --restart unless-stopped -p 80:5000 "${REPO}"
          
          echo "=== Health check (basic) ==="
          sleep 2
          ${DOCKER_BIN} ps
          
          echo "=== Done ==="
          EOS
          )"
      
          # Inject the runner envs into the script (so they're set even if not exported by SSM)
          REMOTE_SCRIPT="AWS_REGION='${AWS_REGION}' AWS_ACCOUNT_ID='${AWS_ACCOUNT_ID}' REPO='${REPO}' DEBUG='${DEBUG}' bash -lc $'$(printf %q "$REMOTE_SCRIPT")'"
      
          echo "----- Rendered remote script (head) -----"
          printf '%s\n' "$REMOTE_SCRIPT" | head -n 10
          echo "----------------------------------------"
      
          PARAMS_JSON=$(jq -nc --arg script "$REMOTE_SCRIPT" '{commands: [$script], executionTimeout: ["3600"], workingDirectory: ["~"]}')
      
          echo "Sending SSM command to: ${INSTANCE_IDS}"
          COMMAND_ID=$(
            aws ssm send-command \
              --document-name "AWS-RunShellScript" \
              --comment "Deploy petstore-api container" \
              --parameters "$PARAMS_JSON" \
              --instance-ids ${INSTANCE_IDS} \
              --timeout-seconds 3600 \
              --output text \
              --query "Command.CommandId" \
              --cloud-watch-output-config "CloudWatchOutputEnabled=false"
          )
          echo "command_id=${COMMAND_ID}" >> "$GITHUB_OUTPUT"
          echo "SSM CommandId: ${COMMAND_ID}"
      
          overall_rc=0
          deadline=$(( $(date +%s) + 900 ))
          for id in ${INSTANCE_IDS}; do
            echo "=== Streaming output for ${id} (CommandId ${COMMAND_ID}) ==="
            while :; do
              now=$(date +%s); [ $now -lt $deadline ] || { echo "::error::Timed out waiting for SSM on ${id}"; overall_rc=1; break; }
              inv=$(aws ssm get-command-invocation --command-id "${COMMAND_ID}" --instance-id "${id}" --output json || true)
              status=$(echo "${inv}"  | jq -r '.Status // "Pending"')
              details=$(echo "${inv}" | jq -r '.StatusDetails // ""')
              stdout=$(echo "${inv}"  | jq -r '.StandardOutputContent // ""')
              stderr=$(echo "${inv}"  | jq -r '.StandardErrorContent // ""')
      
              echo "Status: ${status} (${details})"
              [ -n "${stdout}" ] && echo "----- STDOUT (${id}) -----"$'\n'"${stdout}"
              [ -n "${stderr}" ] && echo "----- STDERR (${id}) -----"$'\n'"${stderr}"
      
              case "${status}" in
                Pending|InProgress|Delayed) sleep 5 ;;
                Success) echo "✅ ${id} completed successfully."; break ;;
                Cancelled|TimedOut|Failed) echo "::error::${id} ended with ${status} (${details})"; overall_rc=1; break ;;
                *) sleep 5 ;;
              esac
            done
          done
      
          exit ${overall_rc}
